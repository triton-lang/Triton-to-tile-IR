//===- Emitter.h - CUDA Tile dialect spec generator helpers -----*- C++ -*-===//
//
// Part of the CUDA Tile IR project, under the Apache License v2.0 with LLVM
// Exceptions. See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
// This file defines helpers used in the CUDA Tile dialect spec generator.
//
//===----------------------------------------------------------------------===//

#ifndef CUDA_TILE_TOOLS_CUDATILETBLGEN_EMITTER_H_
#define CUDA_TILE_TOOLS_CUDATILETBLGEN_EMITTER_H_

#include "mlir/Support/IndentedOstream.h"
#include "mlir/Support/LLVM.h"

#include "llvm/ADT/StringRef.h"
#include "llvm/TableGen/Record.h"

#include <fstream>
#include <iostream>
#include <string>
#include <vector>

using namespace llvm;
using namespace mlir;

namespace cudatile {
namespace tblgen {

inline constexpr const char *AUTO_GENERATED_MESSAGE =
    "Autogenerated by cuda-tile-tblgen; don't manually edit";

// Note: we are included in a larger document so we must start
// with level 2 as our root header.
//
// Levels for the headers.
inline constexpr int SECTION_HEADER_LEVEL = 2;
inline constexpr int OP_HEADER_LEVEL = 3;
inline constexpr int OP_DETAILS_HEADER_LEVEL = 4;

inline constexpr std::string_view indent = "   ";
struct Header {
  int level;
  llvm::StringRef title;
  Header(int level, llvm::StringRef title) : level(level), title(title) {}
  friend raw_ostream &operator<<(raw_ostream &os, const Header &header);
};

raw_ostream& operator<<(raw_ostream& os, const Header& header);

struct CodeBlockStart {
    size_t start;
    size_t length;
    std::string language;
};

/// Finds the starting prefix of an exapmle which may be the start
/// of a code block delimited by ```, or `Example:` or `Examples:` followed
/// by zero or more whitespace or newlines and then a code block delimited
/// by ```. Returns a pair representing the starting index and the length of
/// the string until the final `.
CodeBlockStart findExampleStart(size_t start, StringRef content);

struct CodeBlock {
    std::string language;
    std::string code;
};
struct TableRow {
  std::vector<std::string> columns;
};

enum ColumnFormatType {
  kText,
  kCode,
};
struct TableHeader {
  std::string title;
  // The width of the column including this header, if unset rST renderer will
  // infer the width based on the content.
  std::optional<int> width;
  ColumnFormatType format;

  TableHeader(const std::string &title)
      : title(title), width(std::nullopt), format(kText) {}
  TableHeader(const std::string &title, int width)
      : title(title), width(width), format(kText) {}
  TableHeader(const std::string &title, std::optional<int> width,
              ColumnFormatType format)
      : title(title), width(width), format(format) {}
};

struct Code {
  std::string code;
  operator std::string() const { return ":code:`" + this->code + "`"; }
  friend raw_ostream &operator<<(raw_ostream &os, const Code &code);
};

struct TileIRTy {
  std::string type;
  operator std::string() const { return ":tileirty:`" + this->type + "`"; }
  friend raw_ostream &operator<<(raw_ostream &os, const TileIRTy &type);
};

raw_ostream &operator<<(raw_ostream &os, const Code &code);
struct Table {
  std::string title;
  std::optional<std::string> description;
  std::vector<TableHeader> headers;
  std::vector<TableRow> rows;
  std::vector<std::string> anchors;

  friend raw_ostream &operator<<(raw_ostream &os, const Table &table);
};

raw_ostream &operator<<(raw_ostream &os, const Table &table);

struct CodeBlockOptions {
    std::string language;

    CodeBlockOptions() : language("") {}
    CodeBlockOptions(const std::string &language) : language(language) {}
};

enum BadgeType {
  kPrimary,
  kPrimaryLine,
  kSuccess,
  kSuccessLine,
  kInfo,
  kInfoLine,
  kWarning,
  kWarningLine,
  kDanger,
  kDangerLine,
};

struct FormattedExample {
  std::vector<std::tuple<int, int>> lineRanges;
  std::string content;
  int dedent;
};

struct Badge {
  BadgeType type;
  std::string text;

  Badge(BadgeType type, const std::string &text) : type(type), text(text) {}

  static Badge primary(const std::string &text) {
    return Badge(BadgeType::kPrimary, text);
  }

  static Badge primaryLine(const std::string &text) {
    return Badge(BadgeType::kPrimaryLine, text);
  }

  static Badge success(const std::string &text) {
    return Badge(BadgeType::kSuccess, text);
  }

  static Badge successLine(const std::string &text) {
    return Badge(BadgeType::kSuccessLine, text);
  }

  static Badge info(const std::string &text) {
    return Badge(BadgeType::kInfo, text);
  }

  static Badge infoLine(const std::string &text) {
    return Badge(BadgeType::kInfoLine, text);
  }

  static Badge warning(const std::string &text) {
    return Badge(BadgeType::kWarning, text);
  }

  static Badge warningLine(const std::string &text) {
    return Badge(BadgeType::kWarningLine, text);
  }

  static Badge danger(const std::string &text) {
    return Badge(BadgeType::kDanger, text);
  }

  static Badge dangerLine(const std::string &text) {
    return Badge(BadgeType::kDangerLine, text);
  }

  friend raw_ostream &operator<<(raw_ostream &os, const Badge &badge);
};

raw_ostream &operator<<(raw_ostream &os, const Badge &badge);

/// Emits the specification into a textual form.
class SpecEmitter {
// For now leak the implementation to enable gradual transition to this class.
public:
  // The output stream for writing out the file specification.
  raw_indented_ostream &os;

  // The directory containing the examples for the operation.
  std::optional<std::string> examplesDirectory;

  // The file stream for writing out the examples appendix.
  std::ofstream appendixFile;

  SpecEmitter(raw_indented_ostream &os,
              const std::optional<std::string> &examplesDirectory);
  // todo move impl to .cpp files
  void emitOpHeading(const std::string &op_name,
                     const std::vector<Badge> &badges = {}) {
    this->emitAnchor("op", op_name);
    auto no_check = ":spelling:ignore:`" + op_name + "`";
    this->os << Header(OP_HEADER_LEVEL, no_check);
    for (const auto &badge : badges) {
      this->os << " " << badge;
    }
    this->os << "\n";
  }

  void emitSummary(StringRef summary) {
    if (!summary.empty()) {
      StringRef trimmed = summary.trim();
      char first = std::toupper(trimmed.front());
      StringRef rest = trimmed.drop_front();
      this->os << "\n*" << first << rest << "*\n\n";
    }
  }

  template <typename F>
  void emitCodeBlock(F callback, const CodeBlockOptions &options = {}) {
    this->os << ".. code-block::";
    if (!options.language.empty()) {
      this->os << " " << options.language;
    }
    this->os << "\n\n";
    // We want 4 spaces here.
    this->os.indent();
    this->os.indent();
    callback(this->os);
    // MLIR hardwires unindent to 2 spaces, so we must do it twice.
    //
    // Resetting the indent will break nesting and so unindent must
    // be used.
    this->os.unindent();
    this->os.unindent();
    this->os << "\n\n";
  }

  void emitDescription(StringRef description) {
    auto pos = description.find(":suffix:");
    if (pos != StringRef::npos) {
      this->os.printReindented(description.take_front(pos));
      this->os.printReindented(description.drop_front(pos + 8));
    } else {
      this->os.printReindented(description);
    }

    // TODO normalize the newline to be double break here?
    if (!description.ends_with("\n\n")) {
      this->os << "\n\n";
    }
  }

  void emitAnchor(StringRef anchor) { this->os << ".. _" << anchor << ":\n\n"; }

  void emitAnchor(StringRef anchor_type, StringRef anchor) {
    this->os << ".. _" << anchor_type << "-" << anchor << ":\n\n";
  }

  void emitComment(const std::string &comment) {
    // Emit a newline for RST after the comment as describe is best-practice.
    this->os << ".. " << comment << "\n\n";
  }

  void emitInclude(const std::string &path) {
    this->os << ".. include:: " << path << "\n\n";
  }

  void emitExample(const std::string &exampleName,
                   const FormattedExample &formattedExample);

  /// Write an example to the examples output directory.
  void writeExampleToDiskAndAppendToAppendix(const std::string &exampleName,
                                             const std::string &exampleAnchor,
                                             const std::string &fileName,
                                             const std::string &example);

  void emitLiteralInclude(const std::string &fileName,
                          const std::string &anchor,
                          const std::vector<std::tuple<int, int>> &lineRanges,
                          const std::string &language,
                          std::optional<int> dedent = std::nullopt);
};

} // namespace tblgen
} // namespace cudatile

#endif //  CUDA_TILE_TOOLS_CUDATILETBLGEN_EMITTER_H_
